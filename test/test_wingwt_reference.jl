using JSON3
using laGP
using LinearAlgebra
using Test

include("test_utils.jl")

# Load reference data generated by R laGP
const WINGWT_REF = JSON3.read(
    read(joinpath(@__DIR__, "reference", "wingwt.json"), String)
)

@testset "Wingwt Reference Tests (vs R laGP)" begin
    # Extract training data from reference
    X = _reshape_matrix(Float64.(WINGWT_REF.X), WINGWT_REF.X_nrow, WINGWT_REF.X_ncol)
    Y = Float64.(WINGWT_REF.Y)

    # Extract test data
    X_test = _reshape_matrix(Float64.(WINGWT_REF.X_test), WINGWT_REF.X_test_nrow, WINGWT_REF.X_test_ncol)
    Y_test = Float64.(WINGWT_REF.Y_test)

    # Reference values
    ref_mle_d = Float64.(WINGWT_REF.mle_d)
    ref_mle_g = Float64(WINGWT_REF.mle_g)
    ref_llik = Float64(WINGWT_REF.llik)
    ref_pred_mean = Float64.(WINGWT_REF.pred_mean)
    ref_pred_s2 = Float64.(WINGWT_REF.pred_s2)
    ref_pred_df = Int(WINGWT_REF.pred_df)
    ref_rmse = Float64(WINGWT_REF.rmse)

    @testset "Training data dimensions" begin
        @test size(X) == (200, 9)
        @test length(Y) == 200
        @test size(X_test) == (100, 9)
        @test length(Y_test) == 100
    end

    @testset "Wingwt function values" begin
        # Verify training response range matches R
        @test minimum(Y) ≈ minimum(WINGWT_REF.Y) rtol=1e-10
        @test maximum(Y) ≈ maximum(WINGWT_REF.Y) rtol=1e-10
    end

    @testset "Predictions match R laGP (using MLE hyperparameters)" begin
        # Create GP with the MLE-optimized hyperparameters from R
        # This ensures we're comparing predictions with identical hyperparameters
        gp = new_gp_sep(X, Y, ref_mle_d, ref_mle_g)
        pred = pred_gp_sep(gp, X_test; lite=true)

        # Mean predictions match very closely (within ~1e-6 relative error)
        @test pred.mean ≈ ref_pred_mean rtol=1e-5
        # Variance has slightly more numerical difference due to matrix operations
        @test pred.s2 ≈ ref_pred_s2 rtol=1e-3
        @test pred.df == ref_pred_df
    end

    @testset "Log-likelihood matches R (with MLE hyperparameters)" begin
        gp = new_gp_sep(X, Y, ref_mle_d, ref_mle_g)
        llik = llik_gp_sep(gp)

        @test llik ≈ ref_llik rtol=1e-6
    end

    @testset "RMSE matches R" begin
        gp = new_gp_sep(X, Y, ref_mle_d, ref_mle_g)
        pred = pred_gp_sep(gp, X_test; lite=true)

        rmse = sqrt(mean((Y_test .- pred.mean).^2))
        @test rmse ≈ ref_rmse rtol=1e-6
    end

    @testset "MLE optimization produces reasonable results" begin
        # Start with same initial values as R
        d_init = fill(Float64(WINGWT_REF.d_init), 9)
        g_init = Float64(WINGWT_REF.g_init)

        gp = new_gp_sep(X, Y, d_init, g_init)
        llik_init = llik_gp_sep(gp)

        # Run joint MLE optimization (MAP estimation with priors)
        # This uses jmle_gp_sep which optimizes all d and g jointly
        jmle_gp_sep(gp; drange=(1e-6, 500.0), grange=(1e-10, 1.0))
        llik_final = llik_gp_sep(gp)

        # Verify optimization improved the log-likelihood
        @test llik_final > llik_init

        # Verify hyperparameters are positive and finite
        @test all(gp.d .> 0)
        @test gp.g > 0
        @test all(isfinite.(gp.d))
        @test isfinite(gp.g)

        # Note: Due to differences in optimization algorithms and priors,
        # the exact MLE values may differ from R, but the optimization
        # should still improve the likelihood
    end
end
