<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate Inputs (ARD) · laGP.jl</title><meta name="title" content="Multivariate Inputs (ARD) · laGP.jl"/><meta property="og:title" content="Multivariate Inputs (ARD) · laGP.jl"/><meta property="twitter:title" content="Multivariate Inputs (ARD) · laGP.jl"/><meta name="description" content="Documentation for laGP.jl."/><meta property="og:description" content="Documentation for laGP.jl."/><meta property="twitter:description" content="Documentation for laGP.jl."/><meta property="og:url" content="https://joshualeond.github.io/laGP.jl/stable/examples/multivariate/"/><meta property="twitter:url" content="https://joshualeond.github.io/laGP.jl/stable/examples/multivariate/"/><link rel="canonical" href="https://joshualeond.github.io/laGP.jl/stable/examples/multivariate/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">laGP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../demo/">Local Approximate GP Demo</a></li><li><a class="tocitem" href="../motorcycle/">Motorcycle Crash Test</a></li><li><a class="tocitem" href="../sinusoidal/">Posterior Sampling</a></li><li class="is-active"><a class="tocitem" href>Multivariate Inputs (ARD)</a><ul class="internal"><li><a class="tocitem" href="#Why-Per-Dimension-Lengthscales?"><span>Why Per-Dimension Lengthscales?</span></a></li><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Generate-Training-Data"><span>Generate Training Data</span></a></li><li><a class="tocitem" href="#Initialize-Hyperparameters"><span>Initialize Hyperparameters</span></a></li><li><a class="tocitem" href="#Create-and-Fit-Separable-GP"><span>Create and Fit Separable GP</span></a></li><li><a class="tocitem" href="#Interpreting-the-Lengthscales"><span>Interpreting the Lengthscales</span></a></li><li><a class="tocitem" href="#Prediction"><span>Prediction</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Key-Concepts"><span>Key Concepts</span></a></li></ul></li><li><a class="tocitem" href="../surrogates/">Wing Weight Surrogate</a></li><li><a class="tocitem" href="../satellite/">Satellite Drag Modeling</a></li><li><a class="tocitem" href="../bayesian_optimization/">Bayesian Optimization</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Multivariate Inputs (ARD)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate Inputs (ARD)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/joshualeond/laGP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/joshualeond/laGP.jl/blob/main/docs/src/examples/multivariate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-Inputs-with-ARD"><a class="docs-heading-anchor" href="#Multivariate-Inputs-with-ARD">Multivariate Inputs with ARD</a><a id="Multivariate-Inputs-with-ARD-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Inputs-with-ARD" title="Permalink"></a></h1><p>This example demonstrates how to fit a <strong>separable GP</strong> (also known as ARD - Automatic Relevance Determination) to multi-dimensional input data, allowing the model to learn different lengthscales for each input dimension.</p><h2 id="Why-Per-Dimension-Lengthscales?"><a class="docs-heading-anchor" href="#Why-Per-Dimension-Lengthscales?">Why Per-Dimension Lengthscales?</a><a id="Why-Per-Dimension-Lengthscales?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Per-Dimension-Lengthscales?" title="Permalink"></a></h2><p>In standard (isotropic) GPs, a single lengthscale parameter controls how quickly the function varies across <em>all</em> input dimensions. This assumes the function changes at the same rate regardless of direction - an <strong>isotropic</strong> assumption.</p><p>However, real-world functions are often <strong>anisotropic</strong>: they vary more rapidly in some directions than others. Consider:</p><ul><li>A function of (temperature, pressure) where small temperature changes have large effects but pressure changes matter less</li><li>A spatial process where north-south correlation differs from east-west</li><li>Any problem where some inputs are more &quot;relevant&quot; than others</li></ul><p>The <strong>separable GP</strong> (or ARD kernel) addresses this by assigning a separate lengthscale <code>d[k]</code> to each input dimension <code>k</code>. The kernel becomes:</p><pre><code class="nohighlight hljs">k(x, x&#39;) = exp(-Σₖ (xₖ - x&#39;ₖ)² / dₖ)</code></pre><p>A <strong>smaller lengthscale</strong> means the function varies more rapidly in that dimension (high sensitivity), while a <strong>larger lengthscale</strong> means smoother variation (low sensitivity). After fitting, the relative magnitudes of the lengthscales reveal which inputs matter most - hence &quot;Automatic Relevance Determination.&quot;</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><pre><code class="language-julia hljs">using laGP
using Random
using CairoMakie</code></pre><h2 id="Generate-Training-Data"><a class="docs-heading-anchor" href="#Generate-Training-Data">Generate Training Data</a><a id="Generate-Training-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Training-Data" title="Permalink"></a></h2><p>We use a 2D test function from the tinygp tutorial:</p><pre><code class="language-julia hljs"># Target function: y = sin(x₁) * cos(x₂ + x₁) + noise
# This has anisotropic structure - the sin(x₁) term creates faster variation in x₁

Random.seed!(48392)

n = 100
X = -5.0 .+ 10.0 .* rand(n, 2)  # Uniform on [-5, 5]²

yerr = 0.1
y = sin.(X[:, 1]) .* cos.(X[:, 2] .+ X[:, 1]) .+ yerr .* randn(n)

println(&quot;Training data: $n points in 2D, noise σ = $yerr&quot;)</code></pre><h2 id="Initialize-Hyperparameters"><a class="docs-heading-anchor" href="#Initialize-Hyperparameters">Initialize Hyperparameters</a><a id="Initialize-Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Hyperparameters" title="Permalink"></a></h2><p>Use data-driven initialization for the lengthscales and nugget:</p><pre><code class="language-julia hljs"># darg_sep returns ranges suitable for separable GP
d_info = darg_sep(X)
g_info = garg(y)

println(&quot;Lengthscale range: [$(d_info.ranges[1].min), $(d_info.ranges[1].max)]&quot;)
println(&quot;Nugget range: [$(g_info.min), $(g_info.max)]&quot;)

# Initial lengthscales (same for both dimensions)
d_init = [d_info.ranges[1].start, d_info.ranges[2].start]</code></pre><h2 id="Create-and-Fit-Separable-GP"><a class="docs-heading-anchor" href="#Create-and-Fit-Separable-GP">Create and Fit Separable GP</a><a id="Create-and-Fit-Separable-GP-1"></a><a class="docs-heading-anchor-permalink" href="#Create-and-Fit-Separable-GP" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Create GP with per-dimension lengthscales
gp = new_gp_sep(X, y, d_init, g_info.start)

println(&quot;Initial: d = $(round.(gp.d, sigdigits=4)), g = $(round(gp.g, sigdigits=4))&quot;)

# Joint MLE optimization
drange = (d_info.ranges[1].min, d_info.ranges[1].max)
grange = (g_info.min, g_info.max)

result = jmle_gp_sep!(gp; drange=drange, grange=grange, verb=0)

println(&quot;Optimized: d = $(round.(gp.d, sigdigits=4)), g = $(round(gp.g, sigdigits=4))&quot;)
println(&quot;Log-likelihood: $(round(llik_gp_sep(gp), sigdigits=4))&quot;)</code></pre><h2 id="Interpreting-the-Lengthscales"><a class="docs-heading-anchor" href="#Interpreting-the-Lengthscales">Interpreting the Lengthscales</a><a id="Interpreting-the-Lengthscales-1"></a><a class="docs-heading-anchor-permalink" href="#Interpreting-the-Lengthscales" title="Permalink"></a></h2><p>The optimized lengthscales reveal the function&#39;s anisotropic structure:</p><pre><code class="language-julia hljs">println(&quot;Lengthscale interpretation:&quot;)
println(&quot;  d[1] (x₁ dimension) = $(round(gp.d[1], sigdigits=4))&quot;)
println(&quot;  d[2] (x₂ dimension) = $(round(gp.d[2], sigdigits=4))&quot;)

if gp.d[1] &lt; gp.d[2]
    ratio = gp.d[2] / gp.d[1]
    println(&quot;  → x₁ is $(round(ratio, sigdigits=2))x more sensitive (smaller lengthscale)&quot;)
end</code></pre><p>For our test function <code>sin(x₁) * cos(x₂ + x₁)</code>, we expect <code>d[1] &lt; d[2]</code> because:</p><ul><li>The <code>sin(x₁)</code> term creates oscillations primarily along the x₁ axis</li><li>The <code>cos(x₂ + x₁)</code> term couples both dimensions but adds smoother x₂ dependence</li></ul><p>The MLE correctly identifies that x₁ requires a shorter lengthscale to capture the faster variation.</p><h2 id="Prediction"><a class="docs-heading-anchor" href="#Prediction">Prediction</a><a id="Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Create prediction grid
n_x1, n_x2 = 100, 50
x1_grid = range(-5, 5, length=n_x1)
x2_grid = range(-5, 5, length=n_x2)

# Build test matrix
XX = Matrix{Float64}(undef, n_x1 * n_x2, 2)
let idx = 1
    for j in 1:n_x2
        for i in 1:n_x1
            XX[idx, 1] = x1_grid[i]
            XX[idx, 2] = x2_grid[j]
            idx += 1
        end
    end
end

# Get predictions
pred = pred_gp_sep(gp, XX; lite=true)

# Reshape for plotting
mean_grid = reshape(pred.mean, n_x1, n_x2)
std_grid = reshape(sqrt.(pred.s2), n_x1, n_x2)</code></pre><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><pre><code class="language-julia hljs">fig = Figure(size=(1000, 450))

# Predicted mean surface
ax1 = Axis(fig[1, 1], xlabel=&quot;x₁&quot;, ylabel=&quot;x₂&quot;, title=&quot;Predicted Mean&quot;)
hm1 = heatmap!(ax1, collect(x1_grid), collect(x2_grid), mean_grid&#39;, colormap=:viridis)
scatter!(ax1, X[:, 1], X[:, 2], color=:white, markersize=5,
         strokecolor=:black, strokewidth=0.5)
Colorbar(fig[1, 2], hm1, label=&quot;Mean&quot;)

# Prediction uncertainty
ax2 = Axis(fig[1, 3], xlabel=&quot;x₁&quot;, ylabel=&quot;x₂&quot;, title=&quot;Prediction Uncertainty (Std)&quot;)
hm2 = heatmap!(ax2, collect(x1_grid), collect(x2_grid), std_grid&#39;, colormap=:plasma)
scatter!(ax2, X[:, 1], X[:, 2], color=:white, markersize=5,
         strokecolor=:black, strokewidth=0.5)
Colorbar(fig[1, 4], hm2, label=&quot;Std&quot;)

# Title with optimized hyperparameters
Label(fig[0, :],
      &quot;Separable GP (ARD): d₁=$(round(gp.d[1], sigdigits=3)), d₂=$(round(gp.d[2], sigdigits=3)), g=$(round(gp.g, sigdigits=3))&quot;,
      fontsize=16)

fig</code></pre><p><img src="../../assets/multivariate_example.png" alt="Separable GP Predictions"/></p><p>The left panel shows the predicted mean surface smoothly interpolating the training data (white points). The right panel shows prediction uncertainty - low near training points and higher in regions with sparse data.</p><h2 id="Key-Concepts"><a class="docs-heading-anchor" href="#Key-Concepts">Key Concepts</a><a id="Key-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts" title="Permalink"></a></h2><h3 id="Isotropic-vs-Separable-(ARD)-Kernels"><a class="docs-heading-anchor" href="#Isotropic-vs-Separable-(ARD)-Kernels">Isotropic vs Separable (ARD) Kernels</a><a id="Isotropic-vs-Separable-(ARD)-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Isotropic-vs-Separable-(ARD)-Kernels" title="Permalink"></a></h3><table><tr><th style="text-align: right">Property</th><th style="text-align: right">Isotropic (<code>GP</code>)</th><th style="text-align: right">Separable (<code>GPsep</code>)</th></tr><tr><td style="text-align: right">Lengthscale</td><td style="text-align: right">Single <code>d</code> for all dimensions</td><td style="text-align: right">Vector <code>d[1:m]</code> per dimension</td></tr><tr><td style="text-align: right">Assumption</td><td style="text-align: right">Function varies equally in all directions</td><td style="text-align: right">Function can vary differently per dimension</td></tr><tr><td style="text-align: right">Parameters</td><td style="text-align: right">2 (d, g)</td><td style="text-align: right">m+1 (d[1], ..., d[m], g)</td></tr><tr><td style="text-align: right">Use when</td><td style="text-align: right">Dimensions are interchangeable</td><td style="text-align: right">Dimensions have different relevance</td></tr></table><h3 id="When-to-Use-ARD"><a class="docs-heading-anchor" href="#When-to-Use-ARD">When to Use ARD</a><a id="When-to-Use-ARD-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-ARD" title="Permalink"></a></h3><p>Use <code>GPsep</code> (separable/ARD) when:</p><ul><li><strong>Input dimensions have different scales or units</strong> - e.g., mixing temperature (°C) and concentration (mol/L)</li><li><strong>Some inputs may be irrelevant</strong> - ARD can discover this via large lengthscales</li><li><strong>Physical intuition suggests anisotropy</strong> - directional processes, hierarchical effects</li><li><strong>Variable importance is of interest</strong> - lengthscale ratios indicate relative sensitivity</li></ul><p>Use <code>GP</code> (isotropic) when:</p><ul><li><strong>Dimensions are exchangeable</strong> - e.g., spatial coordinates with no preferred direction</li><li><strong>Limited data</strong> - fewer parameters means less overfitting risk</li><li><strong>Computational efficiency</strong> - isotropic kernels can be slightly faster</li></ul><h3 id="Practical-Notes"><a class="docs-heading-anchor" href="#Practical-Notes">Practical Notes</a><a id="Practical-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Notes" title="Permalink"></a></h3><ol><li><p><strong>Initialization</strong>: Both dimensions start with the same lengthscale. The optimizer then differentiates them based on the data.</p></li><li><p><strong>Identifiability</strong>: With very little data, ARD lengthscales may not be well-determined. Consider isotropic GP if you have fewer than ~10 points per dimension.</p></li><li><p><strong>Scaling inputs</strong>: For best results, normalize inputs to similar ranges before fitting. This prevents numerical issues and makes lengthscale magnitudes comparable.</p></li><li><p><strong>Nugget estimation</strong>: The nugget <code>g</code> captures observation noise plus any unmodeled small-scale variation. A larger nugget indicates noisier data or model misspecification.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sinusoidal/">« Posterior Sampling</a><a class="docs-footer-nextpage" href="../surrogates/">Wing Weight Surrogate »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 15:41">Thursday 29 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
